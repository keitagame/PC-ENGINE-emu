<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>PC-ENGINE-emu</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="nes.png" type="image/png">
    <style>
       :root {
        color-scheme: light dark;
      }
      @font-face {
  font-family: "Renner";
  src: url("./Renner.ttf") format("truetype");
  font-display: swap;
 
}
      body {
        background:rgb(0, 0, 0);
       font-family: "Renner", sans-serif;
        margin: 0;
        padding:0;
      }
h1{
font-weight:300;
font-size:25px;
}
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
       font-size:20px; 
      }
      small {
        opacity: 0.7;
      }
      
button{
font-family: "Renner", sans-serif;
padding:10px;
background:rgb(0, 0, 0);
color:rgb(255, 255, 255);
border:1px solid rgb(255, 255, 255);
}
.file-input {
  display: none; /* 本体は隠す */
}

.file-label {
  display: inline-block;
  padding: 10px 16px;
  background: #000000;
  color: white;
    border:1px solid white;
  border-radius: 0px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}



    </style>
  </head>
  <body>
   
    <header>
<h1>PC-ENGINE</h1>
      
<label class="file-label">
  Select
  <input id="rom" type="file" class="file-input">
</label>
<span id="file-name"></span>

      
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start">Start</button>
      <div class="mono" id="status">No ROM</div>
      <div><span class="mono">CPU PC:</span> <span id="pc" class="mono">0x0000</span></div>
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div style="display:none">
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>

        
      </div>
    </div>

    

    <script type="module">
      const u8 = (n) => n & 0xff;
      const u16 = (n) => n & 0xffff;
      const lo = (n) => n & 0xff;
      const hi = (n) => (n >> 8) & 0xff;
      
      function initMPR() {
  const banks = Math.ceil(this.rom.length / 0x2000)
  const last = banks - 1

  this.mpr[0] = 0x00        // RAM
  this.mpr[1] = 0x01
  this.mpr[2] = 0x80 + (last - 3)
  this.mpr[3] = 0x80 + (last - 2)
  this.mpr[4] = 0x80 + (last - 1)
  this.mpr[5] = 0x80 + last
  this.mpr[6] = 0x80 + last
  this.mpr[7] = 0x80 + last
}

function loadPCE(buf) {
  let rom = new Uint8Array(buf)

  // 512byte ヘッダ除去
  if ((rom.length & 0x1FFF) !== 0) {
    console.warn("512byte header detected, stripping")
    rom = rom.slice(512)
  }

  return rom
}


class VDC {
  constructor(ctx) {
    this.ctx = ctx
    this.fb = new Uint32Array(256 * 240)
    
    // VDC registers
    this.regSelect = 0
    this.regs = new Uint16Array(32)
    
    // VRAM (64KB)
    this.vram = new Uint16Array(0x8000)
    this.vramAddr = 0
    this.vramReadBuffer = 0
    
    // Status
    this.status = 0
    this.scanline = 0
    
    // Default palette (9-bit RGB)
    this.palette = new Uint16Array(512)
    this.initDefaultPalette()
  }

  initDefaultPalette() {
    // Simple grayscale default palette
    for (let i = 0; i < 512; i++) {
      const gray = (i & 0x1f) << 3
      this.palette[i] = (gray << 16) | (gray << 8) | gray
    }
  }
 tick() {
  // 疑似 VBlank
  this.status |= 0x20
}

readStatus() {
  const v = this.status
  this.status &= ~0x20
  return v
}


  writeRegister(port, value) {
    if (port === 0) {
      // Register select
      this.regSelect = value & 0x1f
    } else if (port === 2) {
      // Register write (low byte)
      this.regs[this.regSelect] = (this.regs[this.regSelect] & 0xff00) | (value & 0xff)
      this.handleRegisterWrite()
    } else if (port === 3) {
      // Register write (high byte)
      this.regs[this.regSelect] = (this.regs[this.regSelect] & 0x00ff) | ((value & 0xff) << 8)
      this.handleRegisterWrite()
    }
  }

  readRegister(port) {
    if (port === 0) {
      // Status register
      const stat = this.status
      this.status = 0 // Clear on read
      return stat
    } else if (port === 2) {
      // VRAM read (low byte)
      return this.vramReadBuffer & 0xff
    } else if (port === 3) {
      // VRAM read (high byte)
      const val = (this.vramReadBuffer >> 8) & 0xff
      this.vramReadBuffer = this.vram[this.vramAddr & 0x7fff]
      this.vramAddr = (this.vramAddr + 1) & 0xffff
      return val
    }
    return 0
  }

  handleRegisterWrite() {
    switch (this.regSelect) {
      case 0x00: // MAWR - Memory Address Write Register
        this.vramAddr = this.regs[0] & 0xffff
        break
      case 0x01: // MARR - Memory Address Read Register
        this.vramAddr = this.regs[1] & 0xffff
        this.vramReadBuffer = this.vram[this.vramAddr & 0x7fff]
        this.vramAddr = (this.vramAddr + 1) & 0xffff
        break
      case 0x02: // VWR - VRAM Write Register
        this.vram[this.vramAddr & 0x7fff] = this.regs[2] & 0xffff
        this.vramAddr = (this.vramAddr + 1) & 0xffff
        break
    }
  }

  clear(color = 0x000000) {
    this.fb.fill(color)
  }

  render() {
    // Get BG map dimensions from registers
    const bxr = this.regs[0x0a] || 0
    const byr = this.regs[0x0b] || 0
    const mwr = this.regs[0x09] || 0x2000
    
    // Simple tile rendering (if VRAM has data)
    const batAddr = (bxr & 0x7f) * 0x40 + (byr & 0x3f)
    
    for (let y = 0; y < 240; y++) {
      for (let x = 0; x < 256; x++) {
        const tx = (x >> 3)
        const ty = (y >> 3)
        const px = x & 7
        const py = y & 7
        
        // Get tile from BAT
        const batIndex = (ty * 32 + tx) & 0x7ff
        const tile = this.vram[batIndex] || 0
        const tileNum = tile & 0x7ff
        const paletteNum = (tile >> 12) & 0xf
        
        // Get pixel from character generator
        const charAddr = tileNum * 16 + py
        const charData = this.vram[charAddr] || 0
        const pixelIndex = (charData >> (px * 2)) & 0x3
        
        if (pixelIndex > 0) {
          const colorIndex = paletteNum * 16 + pixelIndex
          const color = this.palette[colorIndex & 0x1ff] || 0x888888
          this.fb[y * 256 + x] = color
        }
      }
    }

    const img = this.ctx.createImageData(256, 240)
    for (let i = 0; i < this.fb.length; i++) {
      const c = this.fb[i]
      img.data[i * 4 + 0] = (c >> 16) & 0xff
      img.data[i * 4 + 1] = (c >> 8) & 0xff
      img.data[i * 4 + 2] = c & 0xff
      img.data[i * 4 + 3] = 255
    }
    this.ctx.putImageData(img, 0, 0)
  }

  tick() {
    this.scanline++
    if (this.scanline >= 262) {
      this.scanline = 0
      this.status |= 0x20 // VBlank flag
    }
  }
}
function hex8(v)  { return v.toString(16).padStart(2, '0') }
function hex16(v) { return v.toString(16).padStart(4, '0') }

class HuC6280 {
  constructor(bus) {
    this.bus = bus
    this.pc = 0
    this.a = 0
    this.x = 0
    this.y = 0
    this.sp = 0xff
    this.p = 0x34 // NV-BDIZC
    this.cycles = 0
    this.inIRQ = false
this.irqPending = false

    // Flags
    this.FLAG_C = 0x01
    this.FLAG_Z = 0x02
    this.FLAG_I = 0x04
    this.FLAG_D = 0x08
    this.FLAG_B = 0x10
    this.FLAG_T = 0x20
    this.FLAG_V = 0x40
    this.FLAG_N = 0x80
  }

 
reset() {
  const lo = this.bus.read(0xfffe)
  const hi = this.bus.read(0xffff)

  console.log(
    '[RESET]',
    'FFFE=', lo.toString(16),
    'FFFF=', hi.toString(16)
  )

  this.pc = (hi << 8) | lo

  this.sp = 0xFF
  this.p  = this.FLAG_I | 0x20   // ★ 正しい初期P
  this.inIRQ = false             // ★ 忘れがち

  this.a = 0
  this.x = 0
  this.y = 0
}


doIRQ(vector) {
  if (this.p & this.FLAG_I) return
  if (this.inIRQ) return

  this.inIRQ = true

  this.push((this.pc >> 8) & 0xff)
  this.push(this.pc & 0xff)
  this.push(this.p & ~this.FLAG_B)

  
this.setFlag(this.FLAG_I, true)
  // ★ IRQ要求クリア（最重要）
  this.bus.irqStatus = 0

  const lo = this.bus.read(vector)
  const hi = this.bus.read((vector + 1) & 0xffff)
  this.pc = (hi << 8) | lo
}


  push(val) {
  this.bus.write(0x0100 | this.sp, val & 0xff)
  this.sp = (this.sp - 1) & 0xff
}
tickTimer() {
  if (!this.timerEnabled) return
  this.timerValue--
  if (this.timerValue < 0) {
    this.timerValue = this.timerLatch
    this.irqStatus |= 0x04
  }
}

pop() {
  this.sp = (this.sp + 1) & 0xff
  return this.bus.read(0x0100 | this.sp)
}


  updateNZ(val) {
    val &= 0xff
    this.setFlag(this.FLAG_Z, val === 0)
    this.setFlag(this.FLAG_N, (val & 0x80) !== 0)
  }

  // Addressing modes
  imm() {
  const val = this.bus.read(this.pc)
  this.pc = (this.pc + 1) & 0xffff
  return val
}


zp() {
  return this.bus.read(this.pc++) & 0xff
}

zpx() {
  return (this.bus.read(this.pc++) + this.x) & 0xff
}

zpy() {
  return (this.bus.read(this.pc++) + this.y) & 0xff
}

abs() {
  const lo = this.bus.read(this.pc++)
  const hi = this.bus.read(this.pc++)
  return (hi << 8) | lo
}
getFlag(flag) {
  return (this.p & flag) !== 0
}
setFlag(flag, val) {
  if (val) this.p |= flag
  else this.p &= ~flag
}
tickTimer() {
  if (!this.timerEnabled) return
  this.timerValue--
  if (this.timerValue < 0) {
    this.timerValue = this.timerLatch
    this.bus.irqStatus |= 0x04
  }
}

abx() {
  return (this.abs() + this.x) & 0xffff
}

aby() {
  return (this.abs() + this.y) & 0xffff
}

  ind() {
  const ptr = this.abs()
  const lo = this.bus.read(ptr)

  // ★ 6502 バグ再現（ページ跨ぎ禁止）
  const hiAddr = (ptr & 0xFF00) | ((ptr + 1) & 0x00FF)
  const hi = this.bus.read(hiAddr)

  return (hi << 8) | lo
}

  izx() {
    const base = (this.bus.read(this.pc++) + this.x) & 0xff
    const lo = this.bus.read(base)
    const hi = this.bus.read((base + 1) & 0xff)
    return (hi << 8) | lo
  }
  izy() {
    const base = this.bus.read(this.pc++)
    const lo = this.bus.read(base)
    const hi = this.bus.read((base + 1) & 0xff)
    //return ((hi << 8) | lo) + this.y & 0xffff
return (((hi << 8) | lo) + this.y) & 0xffff

  }

  branch(cond) {
    const offset = this.bus.read(this.pc++)
    if (cond) {
      const signed = offset < 128 ? offset : offset - 256
      this.pc = (this.pc + signed) & 0xffff
      this.cycles += 1
    }
  }

  step() {
   if (!this.getFlag(this.FLAG_I) && (this.bus.irqStatus & 0x04)) {
    this.bus.irqStatus = 0
    this.doIRQ(0xFFF6)
    return
  }
   const pc = this.pc
  const op = this.bus.read(this.pc)
  this.pc = (this.pc + 1) & 0xffff
//if (!this.getFlag(this.FLAG_I) && (bus.irqStatus & 0x07)) {
//  this.irq()
//}

 



console.log(this.pc.toString(16),op.toString(16));


  
    switch (op) {
      // ADC
      case 0x69: { const val = this.bus.read(this.imm()); this.adc(val); this.cycles += 2; break }
      case 0x65: { const val = this.bus.read(this.zp()); this.adc(val); this.cycles += 3; break }
      case 0x75: { const val = this.bus.read(this.zpx()); this.adc(val); this.cycles += 4; break }
      case 0x6d: { const val = this.bus.read(this.abs()); this.adc(val); this.cycles += 4; break }
      case 0x7d: { const val = this.bus.read(this.abx()); this.adc(val); this.cycles += 4; break }
      case 0x79: { const val = this.bus.read(this.aby()); this.adc(val); this.cycles += 4; break }
      case 0x61: { const val = this.bus.read(this.izx()); this.adc(val); this.cycles += 6; break }
      case 0x71: { const val = this.bus.read(this.izy()); this.adc(val); this.cycles += 5; break }

      // AND
      case 0x29: { this.a &= this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break }
      case 0x25: { this.a &= this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break }
      case 0x35: { this.a &= this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x2d: { this.a &= this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x3d: { this.a &= this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x39: { this.a &= this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x21: { this.a &= this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break }
      case 0x31: { this.a &= this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break }
case 0x80: { // BRA rel
  const off = this.bus.read(this.pc++)
  const s = off < 0x80 ? off : off - 0x100
  this.pc = (this.pc + s) & 0xffff
  this.cycles += 4
  break
}
case 0x03: { // ST0 imm
  const v = this.bus.read(this.pc++)
  this.bus.write(0x0000, v)
  this.cycles += 4
  break
}

case 0x13: { // ST1 imm
  const v = this.bus.read(this.pc++)
  this.bus.write(0x0002, v)
  this.cycles += 4
  break
}

case 0x23: { // ST2 imm
  const v = this.bus.read(this.pc++)
  this.bus.write(0x0003, v)
  this.cycles += 4
  break
}
case 0x0F: // BBR0 zp,rel
case 0x1F:
case 0x2F:
case 0x3F:
case 0x4F:
case 0x5F:
case 0x6F:
case 0x7F: {
  this.pc += 2 // zp + rel をスキップ
  this.cycles += 5
  break
}
case 0xAF: { // LAX abs
  const addr = this.abs()
  const v = this.bus.read(addr)
  this.a = v
  this.x = v
  this.updateNZ(v)
  this.cycles += 4
  break
}
case 0x32: { // SAX zp
  const a = this.zp()
  this.bus.write(a, this.a & this.x)
  this.cycles += 3
  break
}

case 0x64: { // STZ zp
  const a = this.zp()
  this.bus.write(a, 0)
  this.cycles += 3
  break
}
case 0x74: { // STZ zp,X
  const a = this.zpx()
  this.bus.write(a, 0)
  this.cycles += 4
  break
}
case 0x9C: { // STZ abs
  const a = this.abs()
  this.bus.write(a, 0)
  this.cycles += 4
  break
}
case 0x9E: { // STZ abs,X
  const a = this.abx()
  this.bus.write(a, 0)
  this.cycles += 5
  break
}
case 0x53: { // TAM #imm
  const mask = this.bus.read(this.pc++)
  for (let i = 0; i < 8; i++) {
    if (mask & (1 << i)) {
      this.bus.mpr[i] = this.a
    }
  }
  this.cycles += 5
  break
}
case 0x43: { // TMA #imm
  const mask = this.bus.read(this.pc++)
  for (let i = 0; i < 8; i++) {
    if (mask & (1 << i)) {
      this.a = this.bus.mpr[i]
      break
    }
  }
  this.updateNZ(this.a)
  this.cycles += 4
  break
}


      // ASL
      case 0x0a: { this.a = this.asl(this.a); this.cycles += 2; break }
      case 0x06: { const a = this.zp(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 5; break }
      case 0x16: { const a = this.zpx(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 6; break }
      case 0x0e: { const a = this.abs(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 6; break }
      case 0x1e: { const a = this.abx(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 7; break }

      // Branches
      case 0x90: this.branch(!this.getFlag(this.FLAG_C)); this.cycles += 2; break // BCC
      case 0xb0: this.branch(this.getFlag(this.FLAG_C)); this.cycles += 2; break  // BCS
      case 0xf0: this.branch(this.getFlag(this.FLAG_Z)); this.cycles += 2; break  // BEQ
      case 0x30: this.branch(this.getFlag(this.FLAG_N)); this.cycles += 2; break  // BMI
      case 0xd0: this.branch(!this.getFlag(this.FLAG_Z)); this.cycles += 2; break // BNE
      case 0x10: this.branch(!this.getFlag(this.FLAG_N)); this.cycles += 2; break // BPL
      case 0x50: this.branch(!this.getFlag(this.FLAG_V)); this.cycles += 2; break // BVC
      case 0x70: this.branch(this.getFlag(this.FLAG_V)); this.cycles += 2; break  // BVS

      // BIT
      case 0x24: { const v = this.bus.read(this.zp()); this.bit(v); this.cycles += 3; break }
      case 0x2c: { const v = this.bus.read(this.abs()); this.bit(v); this.cycles += 4; break }

    case 0x00: { // BRK
  // PC はすでに +1 されている前提
  this.push((this.pc >> 8) & 0xff)
  this.push(this.pc & 0xff)

  this.push(this.p | this.FLAG_B)
  this.setFlag(this.FLAG_I, true)

  const lo = this.bus.read(0xFFFE)
  const hi = this.bus.read(0xFFFF)
  this.pc = (hi << 8) | lo

  this.cycles += 7
  break
}




      // CLC, CLD, CLI, CLV
      case 0x18: this.setFlag(this.FLAG_C, false); this.cycles += 2; break
      case 0xd8: this.setFlag(this.FLAG_D, false); this.cycles += 2; break
      case 0x58: this.setFlag(this.FLAG_I, false); this.cycles += 2; break
      case 0xb8: this.setFlag(this.FLAG_V, false); this.cycles += 2; break

      // CMP
      case 0xc9: { this.cmp(this.a, this.bus.read(this.imm())); this.cycles += 2; break }
      case 0xc5: { this.cmp(this.a, this.bus.read(this.zp())); this.cycles += 3; break }
      case 0xd5: { this.cmp(this.a, this.bus.read(this.zpx())); this.cycles += 4; break }
      case 0xcd: { this.cmp(this.a, this.bus.read(this.abs())); this.cycles += 4; break }
      case 0xdd: { this.cmp(this.a, this.bus.read(this.abx())); this.cycles += 4; break }
      case 0xd9: { this.cmp(this.a, this.bus.read(this.aby())); this.cycles += 4; break }
      case 0xc1: { this.cmp(this.a, this.bus.read(this.izx())); this.cycles += 6; break }
      case 0xd1: { this.cmp(this.a, this.bus.read(this.izy())); this.cycles += 5; break }

      // CPX
      case 0xe0: { this.cmp(this.x, this.bus.read(this.imm())); this.cycles += 2; break }
      case 0xe4: { this.cmp(this.x, this.bus.read(this.zp())); this.cycles += 3; break }
      case 0xec: { this.cmp(this.x, this.bus.read(this.abs())); this.cycles += 4; break }

      // CPY
      case 0xc0: { this.cmp(this.y, this.bus.read(this.imm())); this.cycles += 2; break }
      case 0xc4: { this.cmp(this.y, this.bus.read(this.zp())); this.cycles += 3; break }
      case 0xcc: { this.cmp(this.y, this.bus.read(this.abs())); this.cycles += 4; break }

      // DEC
      case 0xc6: { const a = this.zp(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 5; break }
      case 0xd6: { const a = this.zpx(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xce: { const a = this.abs(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xde: { const a = this.abx(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 7; break }

      // DEX, DEY
      case 0xca: this.x = (this.x - 1) & 0xff; this.updateNZ(this.x); this.cycles += 2; break
      case 0x88: this.y = (this.y - 1) & 0xff; this.updateNZ(this.y); this.cycles += 2; break

      // EOR
      case 0x49: { this.a ^= this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break }
      case 0x45: { this.a ^= this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break }
      case 0x55: { this.a ^= this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x4d: { this.a ^= this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x5d: { this.a ^= this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x59: { this.a ^= this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x41: { this.a ^= this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break }
      case 0x51: { this.a ^= this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break }

      // INC
      case 0xe6: { const a = this.zp(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 5; break }
      case 0xf6: { const a = this.zpx(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xee: { const a = this.abs(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xfe: { const a = this.abx(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 7; break }

      // INX, INY
      case 0xe8: this.x = (this.x + 1) & 0xff; this.updateNZ(this.x); this.cycles += 2; break
      case 0xc8: this.y = (this.y + 1) & 0xff; this.updateNZ(this.y); this.cycles += 2; break

      // JMP
      case 0x4c: this.pc = this.abs(); this.cycles += 3; break
      case 0x6c: this.pc = this.ind(); this.cycles += 6; break

      // JSR
     case 0x20: { // JSR abs
  const addr = this.abs()
  const ret = (this.pc - 1) & 0xffff

  // ★ 正しい順序（LO → HI）
  this.push(ret & 0xff)
  this.push((ret >> 8) & 0xff)

  this.pc = addr
  this.cycles += 6
  break
}


      // LDA
      case 0xa9: this.a = this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break
      case 0xa5: this.a = this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break
      case 0xb5: this.a = this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xad: this.a = this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xbd: this.a = this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xb9: this.a = this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xa1: this.a = this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break
      case 0xb1: this.a = this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break

      // LDX
      case 0xa2: this.x = this.bus.read(this.imm()); this.updateNZ(this.x); this.cycles += 2; break
      case 0xa6: this.x = this.bus.read(this.zp()); this.updateNZ(this.x); this.cycles += 3; break
      case 0xb6: this.x = this.bus.read(this.zpy()); this.updateNZ(this.x); this.cycles += 4; break
      case 0xae: this.x = this.bus.read(this.abs()); this.updateNZ(this.x); this.cycles += 4; break
      case 0xbe: this.x = this.bus.read(this.aby()); this.updateNZ(this.x); this.cycles += 4; break

      // LDY
      case 0xa0: this.y = this.bus.read(this.imm()); this.updateNZ(this.y); this.cycles += 2; break
      case 0xa4: this.y = this.bus.read(this.zp()); this.updateNZ(this.y); this.cycles += 3; break
      case 0xb4: this.y = this.bus.read(this.zpx()); this.updateNZ(this.y); this.cycles += 4; break
      case 0xac: this.y = this.bus.read(this.abs()); this.updateNZ(this.y); this.cycles += 4; break
      case 0xbc: this.y = this.bus.read(this.abx()); this.updateNZ(this.y); this.cycles += 4; break

      // LSR
      case 0x4a: { this.a = this.lsr(this.a); this.cycles += 2; break }
      case 0x46: { const a = this.zp(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 5; break }
      case 0x56: { const a = this.zpx(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 6; break }
      case 0x4e: { const a = this.abs(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 6; break }
      case 0x5e: { const a = this.abx(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 7; break }

      // NOP
      case 0xea: this.cycles += 2; break

      // ORA
      case 0x09: { this.a |= this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break }
      case 0x05: { this.a |= this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break }
      case 0x15: { this.a |= this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x0d: { this.a |= this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x1d: { this.a |= this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x19: { this.a |= this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x01: { this.a |= this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break }
      case 0x11: { this.a |= this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break }

      // PHA, PHP, PLA, PLP
      case 0x48: this.push(this.a); this.cycles += 3; break
      case 0x08: this.push(this.p | this.FLAG_B); this.cycles += 3; break
      case 0x68: this.a = this.pop(); this.updateNZ(this.a); this.cycles += 4; break
      case 0x28: this.p = (this.pop() & 0xef) | 0x20; this.cycles += 4; break

      // ROL
      case 0x2a: { this.a = this.rol(this.a); this.cycles += 2; break }
      case 0x26: { const a = this.zp(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 5; break }
      case 0x36: { const a = this.zpx(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 6; break }
      case 0x2e: { const a = this.abs(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 6; break }
      case 0x3e: { const a = this.abx(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 7; break }

      // ROR
      case 0x6a: { this.a = this.ror(this.a); this.cycles += 2; break }
      case 0x66: { const a = this.zp(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 5; break }
      case 0x76: { const a = this.zpx(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 6; break }
      case 0x6e: { const a = this.abs(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 6; break }
      case 0x7e: { const a = this.abx(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 7; break }

      // RTI
     case 0x40: { // RTI

  this.p = (this.pop() & 0xEF) | 0x20
  const pcl = this.pop()
  const pch = this.pop()
  this.pc = (pch << 8) | pcl
  this.inIRQ = false

  this.cycles += 6
  break
}


      // RTS
      case 0x60: {
        const lo = this.pop()
        const hi = this.pop()
        this.pc = (((hi << 8) | lo) + 1) & 0xffff

        //this.pc = ((hi << 8) | lo) + 1 & 0xffff
        this.cycles += 6
        break
      }

      // SBC
      case 0xe9: { const val = this.bus.read(this.imm()); this.sbc(val); this.cycles += 2; break }
      case 0xe5: { const val = this.bus.read(this.zp()); this.sbc(val); this.cycles += 3; break }
      case 0xf5: { const val = this.bus.read(this.zpx()); this.sbc(val); this.cycles += 4; break }
      case 0xed: { const val = this.bus.read(this.abs()); this.sbc(val); this.cycles += 4; break }
      case 0xfd: { const val = this.bus.read(this.abx()); this.sbc(val); this.cycles += 4; break }
      case 0xf9: { const val = this.bus.read(this.aby()); this.sbc(val); this.cycles += 4; break }
      case 0xe1: { const val = this.bus.read(this.izx()); this.sbc(val); this.cycles += 6; break }
      case 0xf1: { const val = this.bus.read(this.izy()); this.sbc(val); this.cycles += 5; break }

      // SEC, SED, SEI
      case 0x38: this.setFlag(this.FLAG_C, true); this.cycles += 2; break
      case 0xf8: this.setFlag(this.FLAG_D, true); this.cycles += 2; break
      case 0x78: this.setFlag(this.FLAG_I, true); this.cycles += 2; break

      // STA
      case 0x85: this.bus.write(this.zp(), this.a); this.cycles += 3; break
      case 0x95: this.bus.write(this.zpx(), this.a); this.cycles += 4; break
      case 0x8d: this.bus.write(this.abs(), this.a); this.cycles += 4; break
      case 0x9d: this.bus.write(this.abx(), this.a); this.cycles += 5; break
      case 0x99: this.bus.write(this.aby(), this.a); this.cycles += 5; break
      case 0x81: this.bus.write(this.izx(), this.a); this.cycles += 6; break
      case 0x91: this.bus.write(this.izy(), this.a); this.cycles += 6; break

      // STX
      case 0x86: this.bus.write(this.zp(), this.x); this.cycles += 3; break
      case 0x96: this.bus.write(this.zpy(), this.x); this.cycles += 4; break
      case 0x8e: this.bus.write(this.abs(), this.x); this.cycles += 4; break

      // STY
      case 0x84: this.bus.write(this.zp(), this.y); this.cycles += 3; break
      case 0x94: this.bus.write(this.zpx(), this.y); this.cycles += 4; break
      case 0x8c: this.bus.write(this.abs(), this.y); this.cycles += 4; break

      // TAX, TAY, TSX, TXA, TXS, TYA
      case 0xaa: this.x = this.a; this.updateNZ(this.x); this.cycles += 2; break
      case 0xa8: this.y = this.a; this.updateNZ(this.y); this.cycles += 2; break
      case 0xba: this.x = this.sp; this.updateNZ(this.x); this.cycles += 2; break
      case 0x8a: this.a = this.x; this.updateNZ(this.a); this.cycles += 2; break
      case 0x9a: this.sp = this.x; this.cycles += 2; break
      case 0x98: this.a = this.y; this.updateNZ(this.a); this.cycles += 2; break

      default:
throw new Error(
    `UNIMPL OPCODE ${hex8(op)} at ${hex16(this.pc - 1)}`
  )
        this.cycles += 2
        break
    }
//if (this.irqPending) {
//    this.irqPending = false
 //   this.doIRQ(0xFFF6) // VDC IRQ
 // }
  }

  adc(val) {
    const c = this.getFlag(this.FLAG_C) ? 1 : 0
    const sum = this.a + val + c
    this.setFlag(this.FLAG_C, sum > 0xff)
    this.setFlag(this.FLAG_V, ((this.a ^ sum) & (val ^ sum) & 0x80) !== 0)
    this.a = sum & 0xff
    this.updateNZ(this.a)
  }

  sbc(val) {
    this.adc(val ^ 0xff)
  }

  cmp(reg, val) {
    const result = (reg - val) & 0x1ff
    this.setFlag(this.FLAG_C, result < 0x100)
    this.updateNZ(result & 0xff)
  }

  asl(val) {
    this.setFlag(this.FLAG_C, (val & 0x80) !== 0)
    val = (val << 1) & 0xff
    this.updateNZ(val)
    return val
  }

  lsr(val) {
    this.setFlag(this.FLAG_C, (val & 0x01) !== 0)
    val = (val >> 1) & 0xff
    this.updateNZ(val)
    return val
  }

  rol(val) {
    const c = this.getFlag(this.FLAG_C) ? 1 : 0
    this.setFlag(this.FLAG_C, (val & 0x80) !== 0)
    val = ((val << 1) | c) & 0xff
    this.updateNZ(val)
    return val
  }

  ror(val) {
    const c = this.getFlag(this.FLAG_C) ? 0x80 : 0
    this.setFlag(this.FLAG_C, (val & 0x01) !== 0)
    val = ((val >> 1) | c) & 0xff
    this.updateNZ(val)
    return val
  }

  bit(val) {
    this.setFlag(this.FLAG_Z, (this.a & val) === 0)
    this.setFlag(this.FLAG_N, (val & 0x80) !== 0)
    this.setFlag(this.FLAG_V, (val & 0x40) !== 0)
  }
}


class Bus {
  constructor(rom, vdc) {
    this.rom = rom
    this.vdc = vdc
    this.ram = new Uint8Array(0x2000) // 8KB RAM
    this.io = new Uint8Array(0x400)   // I/O registers
    
    // Memory mapping registers
    this.mpr = new Uint8Array(8)
    for (let i = 0; i < 8; i++) this.mpr[i] = i
    
    // Timer
    this.timerValue = 0
    this.timerLatch = 0
    this.timerEnabled = false
    
    // IRQ
    this.irqDisable = 0x07
    this.irqStatus = 0
  }

  read(addr) {
    addr &= 0xffff
    
    // RAM: $0000-$1FFF
    // ---- HuC6280 ベクタ ----
// RESET / IRQ / BRK ベクタは常に最終 8KB ROM
if (
  addr === 0xFFFE || addr === 0xFFFF || // RESET
  addr === 0xFFF6 || addr === 0xFFF7    // IRQ / BRK
) {
  const base = this.rom.length - 0x2000
  return this.rom[base + (addr & 0x1FFF)] ?? 0
}

    
    // I/O: $0000-$1FFF (mirrored with RAM in some configs)
    // VDC: $0000-$03FF
    // VDC
if (addr === 0x0000) {
  return this.vdc.readStatus()
}
if (addr >= 0x0000 && addr <= 0x0003) {
  return this.vdc.readRegister(addr & 3)
}


    
    // VCE (Video Color Encoder): $0400-$07FF
    if (addr >= 0x0400 && addr <= 0x07FF) {
      return this.readVCE(addr)
    }
    
    // PSG (Sound): $0800-$0BFF
    if (addr >= 0x0800 && addr <= 0x0BFF) {
      return 0 // PSG not implemented
    }
    
    // Timer: $0C00-$0FFF
    if (addr >= 0x0C00 && addr <= 0x0FFF) {
      return this.readTimer(addr)
    }
    
    // Joypad: $1000-$13FF
    if (addr >= 0x1000 && addr <= 0x13FF) {
      return this.readJoypad(addr)
    }
    
    // IRQ: $1400-$17FF
    if (addr >= 0x1400 && addr <= 0x17FF) {
      return this.readIRQ(addr)
    }
    if (addr < 0x2000) {
      return this.ram[addr]
    }
    // Expansion: $1800-$1FFF
    // Bus.read 内
// IRQ / BRK vector



    // Memory mapping
    const page = (addr >> 13) & 0x07
    const offset = addr & 0x1FFF
    const bank = this.mpr[page]
    
    // ROM banks
    if (bank >= 0x80) {
      const romAddr = ((bank - 0x80) * 0x2000) + offset
      if (romAddr < this.rom.length) {
        return this.rom[romAddr]
      }
    }
    
    return 0
  }

  write(addr, val) {
    addr &= 0xffff
    val &= 0xff
    
    // RAM: $0000-$1FFF
    
    
    // VDC: $0000-$03FF
    if (addr === 0x0000) {
  this.vdc.writeAddress(val)
  return
}
if (addr >= 0x0000 && addr <= 0x0003) {
 this.vdc.writeRegister(addr & 3, val)

  return
}


    
    // VCE: $0400-$07FF
    if (addr >= 0x0400 && addr <= 0x07FF) {
      this.writeVCE(addr, val)
      return
    }
    
    // PSG: $0800-$0BFF
    if (addr >= 0x0800 && addr <= 0x0BFF) {
      // PSG not implemented
      return
    }
    
    // Timer: $0C00-$0FFF
    if (addr >= 0x0C00 && addr <= 0x0FFF) {
      this.writeTimer(addr, val)
      return
    }
    
    // Joypad: $1000-$13FF
    if (addr >= 0x1000 && addr <= 0x13FF) {
      this.writeJoypad(addr, val)
      return
    }
    
    // IRQ: $1400-$17FF
    if (addr >= 0x1400 && addr <= 0x17FF) {
      this.writeIRQ(addr, val)
      return
    }
    if (addr < 0x2000) {
      this.ram[addr] = val
      return
    }
    // MPR: Memory mapping
    if (addr >= 0x1FF0 && addr <= 0x1FF7) {
      this.mpr[addr & 0x07] = val
      return
    }

  }

  readVCE(addr) {
    const reg = addr & 0x07
    if (reg === 0x04) {
      // Color table read
      return this.vdc.palette[this.vce.colorAddr & 0x1FF] & 0xFF
    } else if (reg === 0x05) {
      return (this.vdc.palette[this.vce.colorAddr & 0x1FF] >> 8) & 0xFF
    }
    return 0
  }

  writeVCE(addr, val) {
    if (!this.vce) this.vce = { colorAddr: 0 }
    
    const reg = addr & 0x07
    if (reg === 0x00) {
      // Control register
    } else if (reg === 0x02) {
      // Color table address (low)
      this.vce.colorAddr = (this.vce.colorAddr & 0x100) | val
    } else if (reg === 0x03) {
      // Color table address (high)
      this.vce.colorAddr = (this.vce.colorAddr & 0xFF) | ((val & 0x01) << 8)
    } else if (reg === 0x04) {
      // Color table data (low)
      this.vdc.palette[this.vce.colorAddr & 0x1FF] = 
        (this.vdc.palette[this.vce.colorAddr & 0x1FF] & 0xFF00) | val
    } else if (reg === 0x05) {
      // Color table data (high)
      this.vdc.palette[this.vce.colorAddr & 0x1FF] = 
        (this.vdc.palette[this.vce.colorAddr & 0x1FF] & 0x00FF) | ((val & 0x01) << 8)
      this.vce.colorAddr = (this.vce.colorAddr + 1) & 0x1FF
      
      // Convert 9-bit to 24-bit RGB
      const color9 = this.vdc.palette[this.vce.colorAddr & 0x1FF]
      const r = ((color9 >> 3) & 0x07) * 36
      const g = ((color9 >> 6) & 0x07) * 36
      const b = (color9 & 0x07) * 36
      this.vdc.palette[this.vce.colorAddr & 0x1FF] = (r << 16) | (g << 8) | b
    }
  }

  readTimer(addr) {
    const reg = addr & 0x01
    if (reg === 0x00) {
      return this.timerValue & 0x7F
    }
    return 0
  }

  writeTimer(addr, val) {
    const reg = addr & 0x01
    if (reg === 0x00) {
      this.timerLatch = val & 0x7F
    } else if (reg === 0x01) {
      this.timerEnabled = (val & 0x01) !== 0
      if (this.timerEnabled) {
        this.timerValue = this.timerLatch
      }
    }
  }

  readJoypad(addr) {
    // Return button states
    // Bits: Run, Select, -, -, I, II, Right, Left, Down, Up
    return 0xFF // All buttons released
  }

  writeJoypad(addr, val) {
    // Joypad output (multiplexer control)
  }

  readIRQ(addr) {
    const reg = addr & 0x03
    if (reg === 0x02) {
      return this.irqDisable
    } else if (reg === 0x03) {
      const status = this.irqStatus
      this.irqStatus = 0 // Clear on read
      return status
    }
    return 0
  }

  writeIRQ(addr, val) {
    const reg = addr & 0x03
    if (reg === 0x02) {
      this.irqDisable = val & 0x07
    } else if (reg === 0x03) {
      this.irqStatus = 0 // Write clears
    }
  }

  tickTimer() {
    if (this.timerEnabled) {
      this.timerValue--
      if (this.timerValue < 0) {
        this.timerValue = this.timerLatch
        // Trigger timer IRQ
        if ((this.irqDisable & 0x04) === 0) {
          this.irqStatus |= 0x04
        }
      }
    }
  }
}
      // ---------- UI / Main loop ----------
      const canvas = document.getElementById("screen")
const ctx = canvas.getContext("2d")

let cpu, bus, vdc, rom
document.getElementById("start").addEventListener("click", () => {
  if (rom) {
    //cpu.reset()
    run()
  } else {
    alert("Please load a ROM first.")
  }
})
document.getElementById("rom").addEventListener("change", e => {
  const file = e.target.files[0]
  const reader = new FileReader()

  reader.onload = () => {
    rom = loadPCE(reader.result)

    vdc = new VDC(ctx)
    bus = new Bus(rom, vdc)
initMPR.call(bus)
    cpu = new HuC6280(bus)
const romBanks = Math.ceil(rom.length / 0x2000)
console.log("romBank:"+romBanks);
const last = romBanks - 1   // 47

bus.mpr.set([
  0x00,           // $0000-$1FFF RAM
  0x01,           // $2000-$3FFF RAM mirror / IO
  0x02,           // $4000-$5FFF
  0x03,           // $6000-$7FFF
  0x80 + last-3,  // $8000-$9FFF
  0x80 + last-2,  // $A000-$BFFF
  0x80 + last-1,  // $C000-$DFFF
  0x80 + last     // $E000-$FFFF ← RESET
])

    cpu.reset()
    //run()
  }

  reader.readAsArrayBuffer(file)
})
function run() {
  function frame() {
    // 適当な命令数
    for (let i = 0; i < 5000; i++) {
      cpu.step()
      vdc.tick()
      document.getElementById("pc").textContent = `0x${cpu.pc.toString(16)}`;
    }

    vdc.clear(0x002244)
    vdc.render()
    
    requestAnimationFrame(frame)
  }
  frame()
}


    </script>


  </body>
</html>
