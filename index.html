<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>PC-ENGINE</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="nes.png" type="image/png">
    <style>
       :root {
        color-scheme: light dark;
      }
      @font-face {
  font-family: "Renner";
  src: url("./Renner.ttf") format("truetype");
  font-display: swap;
 
}
      body {
        background:rgb(0, 0, 0);
       font-family: "Renner", sans-serif;
        margin: 0;
        padding:0;
      }
h1{
font-weight:300;
font-size:25px;
}
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
       font-size:20px; 
      }
      small {
        opacity: 0.7;
      }
      
button{
font-family: "Renner", sans-serif;
padding:10px;
background:rgb(0, 0, 0);
color:rgb(255, 255, 255);
border:1px solid rgb(255, 255, 255);
}
.file-input {
  display: none; /* 本体は隠す */
}

.file-label {
  display: inline-block;
  padding: 10px 16px;
  background: #000000;
  color: white;
    border:1px solid white;
  border-radius: 0px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}



    </style>
  </head>
  <body>
   
    <header>
<h1>PC-ENGINE</h1>
      
<label class="file-label">
  Select
  <input id="rom" type="file" class="file-input">
</label>
<span id="file-name"></span>

      
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start" disabled>Start</button>
      <div class="mono" id="status">No ROM</div>
      <div><span class="mono">CPU PC:</span> <span id="pc" class="mono">0x0000</span></div>
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div style="display:none">
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>

        
      </div>
    </div>

    

    <script type="module">
      const u8 = (n) => n & 0xff;
      const u16 = (n) => n & 0xffff;
      const lo = (n) => n & 0xff;
      const hi = (n) => (n >> 8) & 0xff;
      
      
function loadPCE(buffer) {
  return new Uint8Array(buffer)
}


class VDC {
  constructor(ctx) {
    this.ctx = ctx
    this.fb = new Uint32Array(256 * 240)
  }

  clear(color = 0x000000) {
    this.fb.fill(color)
  }

  render() {
    const img = this.ctx.createImageData(256, 240)
    for (let i = 0; i < this.fb.length; i++) {
      const c = this.fb[i]
      img.data[i * 4 + 0] = (c >> 16) & 0xff
      img.data[i * 4 + 1] = (c >> 8) & 0xff
      img.data[i * 4 + 2] = c & 0xff
      img.data[i * 4 + 3] = 255
    }
    this.ctx.putImageData(img, 0, 0)
  }
}

class HuC6280 {
  constructor(bus) {
    this.bus = bus
    this.pc = 0
    this.a = 0
    this.x = 0
    this.y = 0
    this.sp = 0xff
    this.p = 0x34 // NV-BDIZC
    this.cycles = 0
    
    // Flags
    this.FLAG_C = 0x01
    this.FLAG_Z = 0x02
    this.FLAG_I = 0x04
    this.FLAG_D = 0x08
    this.FLAG_B = 0x10
    this.FLAG_T = 0x20
    this.FLAG_V = 0x40
    this.FLAG_N = 0x80
  }

  reset() {
    const lo = this.bus.read(0xfffe)
    const hi = this.bus.read(0xffff)
    this.pc = (hi << 8) | lo
    this.sp = 0xfd
    this.p = 0x34
    this.a = 0
    this.x = 0
    this.y = 0
  }

  getFlag(flag) { return (this.p & flag) !== 0 }
  setFlag(flag, val) { 
    if (val) this.p |= flag
    else this.p &= ~flag
  }

  push(val) {
    this.bus.write(0x2100 + this.sp, val & 0xff)
    this.sp = (this.sp - 1) & 0xff
  }

  pop() {
    this.sp = (this.sp + 1) & 0xff
    return this.bus.read(0x2100 + this.sp)
  }

  updateNZ(val) {
    val &= 0xff
    this.setFlag(this.FLAG_Z, val === 0)
    this.setFlag(this.FLAG_N, (val & 0x80) !== 0)
  }

  // Addressing modes
  imm() { return this.pc++ }
  zp() { return this.bus.read(this.pc++) }
  zpx() { return (this.bus.read(this.pc++) + this.x) & 0xff }
  zpy() { return (this.bus.read(this.pc++) + this.y) & 0xff }
  abs() {
    const lo = this.bus.read(this.pc++)
    const hi = this.bus.read(this.pc++)
    return (hi << 8) | lo
  }
  abx() { return (this.abs() + this.x) & 0xffff }
  aby() { return (this.abs() + this.y) & 0xffff }
  ind() {
    const ptr = this.abs()
    const lo = this.bus.read(ptr)
    const hi = this.bus.read((ptr + 1) & 0xffff)
    return (hi << 8) | lo
  }
  izx() {
    const base = (this.bus.read(this.pc++) + this.x) & 0xff
    const lo = this.bus.read(base)
    const hi = this.bus.read((base + 1) & 0xff)
    return (hi << 8) | lo
  }
  izy() {
    const base = this.bus.read(this.pc++)
    const lo = this.bus.read(base)
    const hi = this.bus.read((base + 1) & 0xff)
    return ((hi << 8) | lo) + this.y & 0xffff
  }

  branch(cond) {
    const offset = this.bus.read(this.pc++)
    if (cond) {
      const signed = offset < 128 ? offset : offset - 256
      this.pc = (this.pc + signed) & 0xffff
      this.cycles += 1
    }
  }

  step() {
    const op = this.bus.read(this.pc++)
    
    switch (op) {
      // ADC
      case 0x69: { const val = this.bus.read(this.imm()); this.adc(val); this.cycles += 2; break }
      case 0x65: { const val = this.bus.read(this.zp()); this.adc(val); this.cycles += 3; break }
      case 0x75: { const val = this.bus.read(this.zpx()); this.adc(val); this.cycles += 4; break }
      case 0x6d: { const val = this.bus.read(this.abs()); this.adc(val); this.cycles += 4; break }
      case 0x7d: { const val = this.bus.read(this.abx()); this.adc(val); this.cycles += 4; break }
      case 0x79: { const val = this.bus.read(this.aby()); this.adc(val); this.cycles += 4; break }
      case 0x61: { const val = this.bus.read(this.izx()); this.adc(val); this.cycles += 6; break }
      case 0x71: { const val = this.bus.read(this.izy()); this.adc(val); this.cycles += 5; break }

      // AND
      case 0x29: { this.a &= this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break }
      case 0x25: { this.a &= this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break }
      case 0x35: { this.a &= this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x2d: { this.a &= this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x3d: { this.a &= this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x39: { this.a &= this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x21: { this.a &= this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break }
      case 0x31: { this.a &= this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break }

      // ASL
      case 0x0a: { this.a = this.asl(this.a); this.cycles += 2; break }
      case 0x06: { const a = this.zp(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 5; break }
      case 0x16: { const a = this.zpx(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 6; break }
      case 0x0e: { const a = this.abs(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 6; break }
      case 0x1e: { const a = this.abx(); this.bus.write(a, this.asl(this.bus.read(a))); this.cycles += 7; break }

      // Branches
      case 0x90: this.branch(!this.getFlag(this.FLAG_C)); this.cycles += 2; break // BCC
      case 0xb0: this.branch(this.getFlag(this.FLAG_C)); this.cycles += 2; break  // BCS
      case 0xf0: this.branch(this.getFlag(this.FLAG_Z)); this.cycles += 2; break  // BEQ
      case 0x30: this.branch(this.getFlag(this.FLAG_N)); this.cycles += 2; break  // BMI
      case 0xd0: this.branch(!this.getFlag(this.FLAG_Z)); this.cycles += 2; break // BNE
      case 0x10: this.branch(!this.getFlag(this.FLAG_N)); this.cycles += 2; break // BPL
      case 0x50: this.branch(!this.getFlag(this.FLAG_V)); this.cycles += 2; break // BVC
      case 0x70: this.branch(this.getFlag(this.FLAG_V)); this.cycles += 2; break  // BVS

      // BIT
      case 0x24: { const v = this.bus.read(this.zp()); this.bit(v); this.cycles += 3; break }
      case 0x2c: { const v = this.bus.read(this.abs()); this.bit(v); this.cycles += 4; break }

      // BRK
      case 0x00: {
        this.pc++
        this.push((this.pc >> 8) & 0xff)
        this.push(this.pc & 0xff)
        this.push(this.p | this.FLAG_B)
        this.setFlag(this.FLAG_I, true)
        const lo = this.bus.read(0xfff6)
        const hi = this.bus.read(0xfff7)
        this.pc = (hi << 8) | lo
        this.cycles += 7
        break
      }

      // CLC, CLD, CLI, CLV
      case 0x18: this.setFlag(this.FLAG_C, false); this.cycles += 2; break
      case 0xd8: this.setFlag(this.FLAG_D, false); this.cycles += 2; break
      case 0x58: this.setFlag(this.FLAG_I, false); this.cycles += 2; break
      case 0xb8: this.setFlag(this.FLAG_V, false); this.cycles += 2; break

      // CMP
      case 0xc9: { this.cmp(this.a, this.bus.read(this.imm())); this.cycles += 2; break }
      case 0xc5: { this.cmp(this.a, this.bus.read(this.zp())); this.cycles += 3; break }
      case 0xd5: { this.cmp(this.a, this.bus.read(this.zpx())); this.cycles += 4; break }
      case 0xcd: { this.cmp(this.a, this.bus.read(this.abs())); this.cycles += 4; break }
      case 0xdd: { this.cmp(this.a, this.bus.read(this.abx())); this.cycles += 4; break }
      case 0xd9: { this.cmp(this.a, this.bus.read(this.aby())); this.cycles += 4; break }
      case 0xc1: { this.cmp(this.a, this.bus.read(this.izx())); this.cycles += 6; break }
      case 0xd1: { this.cmp(this.a, this.bus.read(this.izy())); this.cycles += 5; break }

      // CPX
      case 0xe0: { this.cmp(this.x, this.bus.read(this.imm())); this.cycles += 2; break }
      case 0xe4: { this.cmp(this.x, this.bus.read(this.zp())); this.cycles += 3; break }
      case 0xec: { this.cmp(this.x, this.bus.read(this.abs())); this.cycles += 4; break }

      // CPY
      case 0xc0: { this.cmp(this.y, this.bus.read(this.imm())); this.cycles += 2; break }
      case 0xc4: { this.cmp(this.y, this.bus.read(this.zp())); this.cycles += 3; break }
      case 0xcc: { this.cmp(this.y, this.bus.read(this.abs())); this.cycles += 4; break }

      // DEC
      case 0xc6: { const a = this.zp(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 5; break }
      case 0xd6: { const a = this.zpx(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xce: { const a = this.abs(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xde: { const a = this.abx(); const v = (this.bus.read(a) - 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 7; break }

      // DEX, DEY
      case 0xca: this.x = (this.x - 1) & 0xff; this.updateNZ(this.x); this.cycles += 2; break
      case 0x88: this.y = (this.y - 1) & 0xff; this.updateNZ(this.y); this.cycles += 2; break

      // EOR
      case 0x49: { this.a ^= this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break }
      case 0x45: { this.a ^= this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break }
      case 0x55: { this.a ^= this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x4d: { this.a ^= this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x5d: { this.a ^= this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x59: { this.a ^= this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x41: { this.a ^= this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break }
      case 0x51: { this.a ^= this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break }

      // INC
      case 0xe6: { const a = this.zp(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 5; break }
      case 0xf6: { const a = this.zpx(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xee: { const a = this.abs(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 6; break }
      case 0xfe: { const a = this.abx(); const v = (this.bus.read(a) + 1) & 0xff; this.bus.write(a, v); this.updateNZ(v); this.cycles += 7; break }

      // INX, INY
      case 0xe8: this.x = (this.x + 1) & 0xff; this.updateNZ(this.x); this.cycles += 2; break
      case 0xc8: this.y = (this.y + 1) & 0xff; this.updateNZ(this.y); this.cycles += 2; break

      // JMP
      case 0x4c: this.pc = this.abs(); this.cycles += 3; break
      case 0x6c: this.pc = this.ind(); this.cycles += 6; break

      // JSR
      case 0x20: {
        const addr = this.abs()
        const ret = (this.pc - 1) & 0xffff
        this.push((ret >> 8) & 0xff)
        this.push(ret & 0xff)
        this.pc = addr
        this.cycles += 6
        break
      }

      // LDA
      case 0xa9: this.a = this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break
      case 0xa5: this.a = this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break
      case 0xb5: this.a = this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xad: this.a = this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xbd: this.a = this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xb9: this.a = this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break
      case 0xa1: this.a = this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break
      case 0xb1: this.a = this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break

      // LDX
      case 0xa2: this.x = this.bus.read(this.imm()); this.updateNZ(this.x); this.cycles += 2; break
      case 0xa6: this.x = this.bus.read(this.zp()); this.updateNZ(this.x); this.cycles += 3; break
      case 0xb6: this.x = this.bus.read(this.zpy()); this.updateNZ(this.x); this.cycles += 4; break
      case 0xae: this.x = this.bus.read(this.abs()); this.updateNZ(this.x); this.cycles += 4; break
      case 0xbe: this.x = this.bus.read(this.aby()); this.updateNZ(this.x); this.cycles += 4; break

      // LDY
      case 0xa0: this.y = this.bus.read(this.imm()); this.updateNZ(this.y); this.cycles += 2; break
      case 0xa4: this.y = this.bus.read(this.zp()); this.updateNZ(this.y); this.cycles += 3; break
      case 0xb4: this.y = this.bus.read(this.zpx()); this.updateNZ(this.y); this.cycles += 4; break
      case 0xac: this.y = this.bus.read(this.abs()); this.updateNZ(this.y); this.cycles += 4; break
      case 0xbc: this.y = this.bus.read(this.abx()); this.updateNZ(this.y); this.cycles += 4; break

      // LSR
      case 0x4a: { this.a = this.lsr(this.a); this.cycles += 2; break }
      case 0x46: { const a = this.zp(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 5; break }
      case 0x56: { const a = this.zpx(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 6; break }
      case 0x4e: { const a = this.abs(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 6; break }
      case 0x5e: { const a = this.abx(); this.bus.write(a, this.lsr(this.bus.read(a))); this.cycles += 7; break }

      // NOP
      case 0xea: this.cycles += 2; break

      // ORA
      case 0x09: { this.a |= this.bus.read(this.imm()); this.updateNZ(this.a); this.cycles += 2; break }
      case 0x05: { this.a |= this.bus.read(this.zp()); this.updateNZ(this.a); this.cycles += 3; break }
      case 0x15: { this.a |= this.bus.read(this.zpx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x0d: { this.a |= this.bus.read(this.abs()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x1d: { this.a |= this.bus.read(this.abx()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x19: { this.a |= this.bus.read(this.aby()); this.updateNZ(this.a); this.cycles += 4; break }
      case 0x01: { this.a |= this.bus.read(this.izx()); this.updateNZ(this.a); this.cycles += 6; break }
      case 0x11: { this.a |= this.bus.read(this.izy()); this.updateNZ(this.a); this.cycles += 5; break }

      // PHA, PHP, PLA, PLP
      case 0x48: this.push(this.a); this.cycles += 3; break
      case 0x08: this.push(this.p | this.FLAG_B); this.cycles += 3; break
      case 0x68: this.a = this.pop(); this.updateNZ(this.a); this.cycles += 4; break
      case 0x28: this.p = (this.pop() & 0xef) | 0x20; this.cycles += 4; break

      // ROL
      case 0x2a: { this.a = this.rol(this.a); this.cycles += 2; break }
      case 0x26: { const a = this.zp(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 5; break }
      case 0x36: { const a = this.zpx(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 6; break }
      case 0x2e: { const a = this.abs(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 6; break }
      case 0x3e: { const a = this.abx(); this.bus.write(a, this.rol(this.bus.read(a))); this.cycles += 7; break }

      // ROR
      case 0x6a: { this.a = this.ror(this.a); this.cycles += 2; break }
      case 0x66: { const a = this.zp(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 5; break }
      case 0x76: { const a = this.zpx(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 6; break }
      case 0x6e: { const a = this.abs(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 6; break }
      case 0x7e: { const a = this.abx(); this.bus.write(a, this.ror(this.bus.read(a))); this.cycles += 7; break }

      // RTI
      case 0x40: {
        this.p = (this.pop() & 0xef) | 0x20
        const lo = this.pop()
        const hi = this.pop()
        this.pc = (hi << 8) | lo
        this.cycles += 6
        break
      }

      // RTS
      case 0x60: {
        const lo = this.pop()
        const hi = this.pop()
        this.pc = ((hi << 8) | lo) + 1 & 0xffff
        this.cycles += 6
        break
      }

      // SBC
      case 0xe9: { const val = this.bus.read(this.imm()); this.sbc(val); this.cycles += 2; break }
      case 0xe5: { const val = this.bus.read(this.zp()); this.sbc(val); this.cycles += 3; break }
      case 0xf5: { const val = this.bus.read(this.zpx()); this.sbc(val); this.cycles += 4; break }
      case 0xed: { const val = this.bus.read(this.abs()); this.sbc(val); this.cycles += 4; break }
      case 0xfd: { const val = this.bus.read(this.abx()); this.sbc(val); this.cycles += 4; break }
      case 0xf9: { const val = this.bus.read(this.aby()); this.sbc(val); this.cycles += 4; break }
      case 0xe1: { const val = this.bus.read(this.izx()); this.sbc(val); this.cycles += 6; break }
      case 0xf1: { const val = this.bus.read(this.izy()); this.sbc(val); this.cycles += 5; break }

      // SEC, SED, SEI
      case 0x38: this.setFlag(this.FLAG_C, true); this.cycles += 2; break
      case 0xf8: this.setFlag(this.FLAG_D, true); this.cycles += 2; break
      case 0x78: this.setFlag(this.FLAG_I, true); this.cycles += 2; break

      // STA
      case 0x85: this.bus.write(this.zp(), this.a); this.cycles += 3; break
      case 0x95: this.bus.write(this.zpx(), this.a); this.cycles += 4; break
      case 0x8d: this.bus.write(this.abs(), this.a); this.cycles += 4; break
      case 0x9d: this.bus.write(this.abx(), this.a); this.cycles += 5; break
      case 0x99: this.bus.write(this.aby(), this.a); this.cycles += 5; break
      case 0x81: this.bus.write(this.izx(), this.a); this.cycles += 6; break
      case 0x91: this.bus.write(this.izy(), this.a); this.cycles += 6; break

      // STX
      case 0x86: this.bus.write(this.zp(), this.x); this.cycles += 3; break
      case 0x96: this.bus.write(this.zpy(), this.x); this.cycles += 4; break
      case 0x8e: this.bus.write(this.abs(), this.x); this.cycles += 4; break

      // STY
      case 0x84: this.bus.write(this.zp(), this.y); this.cycles += 3; break
      case 0x94: this.bus.write(this.zpx(), this.y); this.cycles += 4; break
      case 0x8c: this.bus.write(this.abs(), this.y); this.cycles += 4; break

      // TAX, TAY, TSX, TXA, TXS, TYA
      case 0xaa: this.x = this.a; this.updateNZ(this.x); this.cycles += 2; break
      case 0xa8: this.y = this.a; this.updateNZ(this.y); this.cycles += 2; break
      case 0xba: this.x = this.sp; this.updateNZ(this.x); this.cycles += 2; break
      case 0x8a: this.a = this.x; this.updateNZ(this.a); this.cycles += 2; break
      case 0x9a: this.sp = this.x; this.cycles += 2; break
      case 0x98: this.a = this.y; this.updateNZ(this.a); this.cycles += 2; break

      default:
        console.warn(`Unknown opcode: ${op.toString(16).toUpperCase().padStart(2, '0')} at PC=${(this.pc-1).toString(16).toUpperCase()}`)
        this.cycles += 2
        break
    }
  }

  adc(val) {
    const c = this.getFlag(this.FLAG_C) ? 1 : 0
    const sum = this.a + val + c
    this.setFlag(this.FLAG_C, sum > 0xff)
    this.setFlag(this.FLAG_V, ((this.a ^ sum) & (val ^ sum) & 0x80) !== 0)
    this.a = sum & 0xff
    this.updateNZ(this.a)
  }

  sbc(val) {
    this.adc(val ^ 0xff)
  }

  cmp(reg, val) {
    const result = (reg - val) & 0x1ff
    this.setFlag(this.FLAG_C, result < 0x100)
    this.updateNZ(result & 0xff)
  }

  asl(val) {
    this.setFlag(this.FLAG_C, (val & 0x80) !== 0)
    val = (val << 1) & 0xff
    this.updateNZ(val)
    return val
  }

  lsr(val) {
    this.setFlag(this.FLAG_C, (val & 0x01) !== 0)
    val = (val >> 1) & 0xff
    this.updateNZ(val)
    return val
  }

  rol(val) {
    const c = this.getFlag(this.FLAG_C) ? 1 : 0
    this.setFlag(this.FLAG_C, (val & 0x80) !== 0)
    val = ((val << 1) | c) & 0xff
    this.updateNZ(val)
    return val
  }

  ror(val) {
    const c = this.getFlag(this.FLAG_C) ? 0x80 : 0
    this.setFlag(this.FLAG_C, (val & 0x01) !== 0)
    val = ((val >> 1) | c) & 0xff
    this.updateNZ(val)
    return val
  }

  bit(val) {
    this.setFlag(this.FLAG_Z, (this.a & val) === 0)
    this.setFlag(this.FLAG_N, (val & 0x80) !== 0)
    this.setFlag(this.FLAG_V, (val & 0x40) !== 0)
  }
}


class Bus {
  constructor(rom, vdc) {
    this.rom = rom
    this.vdc = vdc
    this.ram = new Uint8Array(0x2000) // 8KB
  }

  read(addr) {
    addr &= 0xffff

    if (addr < 0x2000) return this.ram[addr]

    // VDC（今はダミー）
    if (addr >= 0x0000 && addr <= 0x1fff) {
      return 0
    }

    // ROM $8000-$FFFF
    if (addr >= 0x8000) {
      return this.rom[addr - 0x8000]
    }

    return 0
  }

  write(addr, val) {
    addr &= 0xffff
    val &= 0xff

    if (addr < 0x2000) {
      this.ram[addr] = val
      return
    }

    // VDC（未実装）
  }
}

      // ---------- UI / Main loop ----------
      const canvas = document.getElementById("screen")
const ctx = canvas.getContext("2d")

let cpu, bus, vdc, rom

document.getElementById("rom").addEventListener("change", e => {
  const file = e.target.files[0]
  const reader = new FileReader()

  reader.onload = () => {
    rom = loadPCE(reader.result)

    vdc = new VDC(ctx)
    bus = new Bus(rom, vdc)
    cpu = new HuC6280(bus)

    cpu.reset()
    run()
  }

  reader.readAsArrayBuffer(file)
})
function run() {
  function frame() {
    // 適当な命令数
    for (let i = 0; i < 5000; i++) {
      cpu.step()
    }

    vdc.clear(0x002244)
    vdc.render()
    document.getElementById("pc").textContent = `0x${cpu.pc.toString(16).toUpperCase().padStart(4, '0')}`;
    requestAnimationFrame(frame)
  }
  frame()
}


    </script>


  </body>
</html>